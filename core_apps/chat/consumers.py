import json
from typing import Any

from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth.models import AnonymousUser
from django.contrib.auth import get_user_model

from core_apps.chat.models import ChatMessage


User = get_user_model()


class ChatConsumer(AsyncWebsocketConsumer):
    """
    ChatConsumer handles websocket connections for a chat application.

    This consumer manages the websocket connection lifecycle (connect, receive, disconnect) and
    handles messaging between users. It ensures that messages are sent to the correct channel
    group and saved to the database.
    """

    @database_sync_to_async
    def get_user_or_none(self, user_id: int) -> User | None:
        """
        Return the user if the user id exists else None.
        """
        try:
            user = User.objects.get(id=user_id)
            return user
        except User.DoesNotExist:
            return False

    async def connect(self):
        """
        Connect to the websocket client if user is not anonymous and the other user exists.
        The unique room name is generated by combining the unique ids of the two users, which
        is always set to order in ascending order.
        """
        self.user = self.scope["user"]
        other_user_id = self.scope["url_route"]["kwargs"]["id"]
        self.other_user = await self.get_user_or_none(other_user_id)
        if (
            isinstance(self.user, AnonymousUser)
            or not self.other_user
            or self.user.id == other_user_id
        ):
            # bad request, close the connection
            await self.close(code=4001)
            return

        if self.user.id < other_user_id:
            self.room_name = f"{self.user.id}-{other_user_id}"
        else:
            self.room_name = f"{other_user_id}-{self.user.id}"

        self.room_group_name = f"chat_{self.room_name}"

        await self.channel_layer.group_add(self.room_group_name, self.channel_name)
        await self.accept()

    async def disconnect(self, close_code):
        """
        Handles the disconnection of the websocket.
        """
        await self.channel_layer.group_discard(self.room_group_name, self.channel_name)

    async def receive(self, text_data):
        """
        Handles the reception of a message from websocket and sends it to appropriate
        channel group. Also calls the save_message function which saves the message
        entry to the database.
        """

        text_data_json = json.loads(text_data)
        message = text_data_json["message"]
        await self.channel_layer.group_send(
            self.room_group_name,
            {"type": "chat.message", "message": message, "sender": self.user.username},
        )
        await self.save_message(self.user, self.other_user, message)

    async def chat_message(self, event: dict[str, Any]):
        """
        Receive message from room group and send to websocket
        """
        await self.send(text_data=json.dumps(event))

    @database_sync_to_async
    def save_message(self, sender: User, receiver: User, message: str) -> ChatMessage:
        """
        Save the message to the database.
        """
        return ChatMessage.objects.create(
            sender=sender, receiver=receiver, message=message
        )
